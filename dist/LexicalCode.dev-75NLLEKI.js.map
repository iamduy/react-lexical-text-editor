{"version":3,"sources":["../node_modules/@lexical/code/LexicalCode.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, $getAdjacentCaret, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $create, TextNode, $applyNodeReplacement, $getSiblingCaret, getTextDirection, $isElementNode, $isLineBreakNode, defineExtension, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, $createPoint, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, $setSelectionFromCaretRange, $getCaretRangeInDirection, $getCaretRange, $getTextPointCaret, $normalizeCaret, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\nconst THEME_DATA_ATTRIBUTE = 'data-theme';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n  __language;\n  /** @internal */\n  __theme;\n  /** @internal */\n  __isSyntaxHighlightSupported;\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language || undefined;\n    this.__isSyntaxHighlightSupported = false;\n    this.__theme = undefined;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__language = prevNode.__language;\n    this.__theme = prevNode.__theme;\n    this.__isSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    const theme = this.getTheme();\n    if (theme) {\n      element.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n    }\n    const style = this.getStyle();\n    if (style) {\n      element.setAttribute('style', style);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    const isSyntaxHighlightSupported = this.__isSyntaxHighlightSupported;\n    const prevIsSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;\n    if (prevIsSyntaxHighlightSupported && prevLanguage) {\n      if (isSyntaxHighlightSupported && language) {\n        if (language !== prevLanguage) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      } else {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    } else if (isSyntaxHighlightSupported && language) {\n      dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    const theme = this.__theme;\n    const prevTheme = prevNode.__theme;\n    if (theme) {\n      if (theme !== prevTheme) {\n        dom.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n      }\n    } else if (prevTheme) {\n      dom.removeAttribute(THEME_DATA_ATTRIBUTE);\n    }\n    const style = this.__style;\n    const prevStyle = prevNode.__style;\n    if (style) {\n      if (style !== prevStyle) {\n        dom.setAttribute('style', style);\n      }\n    } else if (prevStyle) {\n      dom.removeAttribute('style');\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    const theme = this.getTheme();\n    if (theme) {\n      element.setAttribute(THEME_DATA_ATTRIBUTE, theme);\n    }\n    const style = this.getStyle();\n    if (style) {\n      element.setAttribute('style', style);\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createCodeNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language).setTheme(serializedNode.theme);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      theme: this.getTheme()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = $getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language || undefined;\n    return writable;\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  setIsSyntaxHighlightSupported(isSupported) {\n    const writable = this.getWritable();\n    writable.__isSyntaxHighlightSupported = isSupported;\n    return writable;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n  setTheme(theme) {\n    const writable = this.getWritable();\n    writable.__theme = theme || undefined;\n    return writable;\n  }\n  getTheme() {\n    return this.getLatest().__theme;\n  }\n}\nfunction $createCodeNode(language, theme) {\n  return $create(CodeNode).setLanguage(language).setTheme(theme);\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n  __highlightType;\n  constructor(text = '', highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  setHighlightType(highlightType) {\n    const self = this.getWritable();\n    self.__highlightType = highlightType || undefined;\n    return self;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    return $createCodeHighlightNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType()\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text = '', highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\n\nfunction $getLastMatchingCodeNode(anchor, direction) {\n  let matchingNode = anchor;\n  for (let caret = $getSiblingCaret(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode(caret.origin)); caret = $getAdjacentCaret(caret)) {\n    matchingNode = caret.origin;\n  }\n  return matchingNode;\n}\nfunction $getFirstCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'previous');\n}\nfunction $getLastCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'next');\n}\n\n/**\n * Determines the visual writing direction of a code line.\n *\n * Scans the line segments (CodeHighlightNode/TabNode) from start to end\n * and returns the first strong direction found (\"ltr\" or \"rtl\").\n * If no strong character is found, falls back to the parent element's\n * direction. Returns null if indeterminate.\n */\nfunction $getCodeLineDirection(anchor) {\n  const start = $getFirstCodeNodeOfLine(anchor);\n  const end = $getLastCodeNodeOfLine(anchor);\n  let node = start;\n  while (node !== null) {\n    if ($isCodeHighlightNode(node)) {\n      const direction = getTextDirection(node.getTextContent());\n      if (direction !== null) {\n        return direction;\n      }\n    }\n    if (node === end) {\n      break;\n    }\n    node = node.getNextSibling();\n  }\n  const parent = start.getParent();\n  if ($isElementNode(parent)) {\n    const parentDirection = parent.getDirection();\n    if (parentDirection === 'ltr' || parentDirection === 'rtl') {\n      return parentDirection;\n    }\n  }\n  return null;\n}\nfunction $getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        formatDevErrorMessage(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction $getEndOfCodeInLine(anchor) {\n  const lastNode = $getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    formatDevErrorMessage(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Add code blocks to the editor (syntax highlighting provided separately)\n */\nconst CodeExtension = defineExtension({\n  name: '@lexical/code',\n  nodes: () => [CodeNode, CodeHighlightNode]\n});\n\n(function (Prism) {\n\n\tPrism.languages.diff = {\n\t\t'coord': [\n\t\t\t// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n\t\t\t/^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n\t\t\t// Match \"@@ ... @@\" coord lines in unified diff.\n\t\t\t/^@@.*@@$/m,\n\t\t\t// Match coord lines in normal diff (starts with a number).\n\t\t\t/^\\d.*$/m\n\t\t]\n\n\t\t// deleted, inserted, unchanged, diff\n\t};\n\n\t/**\n\t * A map from the name of a block to its line prefix.\n\t *\n\t * @type {Object<string, string>}\n\t */\n\tvar PREFIXES = {\n\t\t'deleted-sign': '-',\n\t\t'deleted-arrow': '<',\n\t\t'inserted-sign': '+',\n\t\t'inserted-arrow': '>',\n\t\t'unchanged': ' ',\n\t\t'diff': '!',\n\t};\n\n\t// add a token for each prefix\n\tObject.keys(PREFIXES).forEach(function (name) {\n\t\tvar prefix = PREFIXES[name];\n\n\t\tvar alias = [];\n\t\tif (!/^\\w+$/.test(name)) { // \"deleted-sign\" -> \"deleted\"\n\t\t\talias.push(/\\w+/.exec(name)[0]);\n\t\t}\n\t\tif (name === 'diff') {\n\t\t\talias.push('bold');\n\t\t}\n\n\t\tPrism.languages.diff[name] = {\n\t\t\tpattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n\t\t\talias: alias,\n\t\t\tinside: {\n\t\t\t\t'line': {\n\t\t\t\t\tpattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'prefix': {\n\t\t\t\t\tpattern: /[\\s\\S]/,\n\t\t\t\t\talias: /\\w+/.exec(name)[0]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t});\n\n\t// make prefixes available to Diff plugin\n\tObject.defineProperty(Prism.languages.diff, 'PREFIXES', {\n\t\tvalue: PREFIXES\n\t});\n\n}(Prism));\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism$1 = globalThis.Prism || window.Prism;\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getCodeLanguages = () => Object.keys(Prism$1.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism$1.languages[language] !== 'function').sort();\nfunction getCodeLanguageOptions() {\n  const options = [];\n  for (const [lang, friendlyName] of Object.entries(CODE_LANGUAGE_FRIENDLY_NAME_MAP)) {\n    options.push([lang, friendlyName]);\n  }\n  return options;\n}\n\n// Prism has no theme support\nfunction getCodeThemeOptions() {\n  const options = [];\n  return options;\n}\nfunction getDiffedLanguage(language) {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);\n  return diffLanguageMatch ? diffLanguageMatch[1] : null;\n}\nfunction isCodeLanguageLoaded(language) {\n  const diffedLanguage = getDiffedLanguage(language);\n  const langId = diffedLanguage ? diffedLanguage : language;\n  try {\n    // eslint-disable-next-line no-prototype-builtins\n    return langId ? Prism$1.languages.hasOwnProperty(langId) : false;\n  } catch (_unused) {\n    return false;\n  }\n}\nasync function loadCodeLanguage(language, editor, codeNodeKey) {\n  // NOT IMPLEMENTED\n}\nfunction getTextContent(token) {\n  if (typeof token === 'string') {\n    return token;\n  } else if (Array.isArray(token)) {\n    return token.map(getTextContent).join('');\n  } else {\n    return getTextContent(token.content);\n  }\n}\n\n// The following code is extracted/adapted from prismjs v2\n// It will probably be possible to use it directly from prism v2\n// in the future when prismjs v2 is published and Lexical upgrades\n// the prismsjs dependency\nfunction tokenizeDiffHighlight(tokens, language) {\n  const diffLanguage = language;\n  const diffGrammar = Prism$1.languages[diffLanguage];\n  const env = {\n    tokens\n  };\n  const PREFIXES = Prism$1.languages.diff.PREFIXES;\n  for (const token of env.tokens) {\n    if (typeof token === 'string' || !(token.type in PREFIXES) || !Array.isArray(token.content)) {\n      continue;\n    }\n    const type = token.type;\n    let insertedPrefixes = 0;\n    const getPrefixToken = () => {\n      insertedPrefixes++;\n      return new Prism$1.Token('prefix', PREFIXES[type], type.replace(/^(\\w+).*/, '$1'));\n    };\n    const withoutPrefixes = token.content.filter(t => typeof t === 'string' || t.type !== 'prefix');\n    const prefixCount = token.content.length - withoutPrefixes.length;\n    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);\n\n    // re-insert prefixes\n    // always add a prefix at the start\n    diffTokens.unshift(getPrefixToken());\n    const LINE_BREAK = /\\r\\n|\\n/g;\n    const insertAfterLineBreakString = text => {\n      const result = [];\n      LINE_BREAK.lastIndex = 0;\n      let last = 0;\n      let m;\n      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {\n        const end = m.index + m[0].length;\n        result.push(text.slice(last, end));\n        last = end;\n        result.push(getPrefixToken());\n      }\n      if (result.length === 0) {\n        return undefined;\n      }\n      if (last < text.length) {\n        result.push(text.slice(last));\n      }\n      return result;\n    };\n    const insertAfterLineBreak = toks => {\n      for (let i = 0; i < toks.length && insertedPrefixes < prefixCount; i++) {\n        const tok = toks[i];\n        if (typeof tok === 'string') {\n          const inserted = insertAfterLineBreakString(tok);\n          if (inserted) {\n            toks.splice(i, 1, ...inserted);\n            i += inserted.length - 1;\n          }\n        } else if (typeof tok.content === 'string') {\n          const inserted = insertAfterLineBreakString(tok.content);\n          if (inserted) {\n            tok.content = inserted;\n          }\n        } else if (Array.isArray(tok.content)) {\n          insertAfterLineBreak(tok.content);\n        } else {\n          insertAfterLineBreak([tok.content]);\n        }\n      }\n    };\n    insertAfterLineBreak(diffTokens);\n    if (insertedPrefixes < prefixCount) {\n      // we are missing the last prefix\n      diffTokens.push(getPrefixToken());\n    }\n    token.content = diffTokens;\n  }\n  return env.tokens;\n}\nfunction $getHighlightNodes(codeNode, language) {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);\n  const code = codeNode.getTextContent();\n  let tokens = Prism$1.tokenize(code, Prism$1.languages[diffLanguageMatch ? 'diff' : language]);\n  if (diffLanguageMatch) {\n    tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);\n  }\n  return $mapTokensToLexicalStructure(tokens);\n}\nfunction $mapTokensToLexicalStructure(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content,\n        alias\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$mapTokensToLexicalStructure([content], token.type === 'prefix' && typeof alias === 'string' ? alias : token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$mapTokensToLexicalStructure(content, token.type === 'unchanged' ? undefined : token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\nconst PrismTokenizer = {\n  $tokenize(codeNode, language) {\n    return $getHighlightNodes(codeNode, language || this.defaultLanguage);\n  },\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism$1.tokenize(code, Prism$1.languages[language || ''] || Prism$1.languages[this.defaultLanguage]);\n  }\n};\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  const cacheKey = editor.getKey() + '/' + nodeKey;\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n  const language = node.getLanguage() || tokenizer.defaultLanguage;\n  if (isCodeLanguageLoaded(language)) {\n    if (!node.getIsSyntaxHighlightSupported()) {\n      node.setIsSyntaxHighlightSupported(true);\n    }\n  } else {\n    if (node.getIsSyntaxHighlightSupported()) {\n      node.setIsSyntaxHighlightSupported(false);\n    }\n    loadCodeLanguage(language, editor, nodeKey);\n    return;\n  }\n  if (nodesCurrentlyHighlighting.has(cacheKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(cacheKey);\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual CodeHighlightNode to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      //const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;\n      //const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(currentLanguage);\n\n      const highlightNodes = tokenizer.$tokenize(currentNode, currentLanguage);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(cacheKey);\n    },\n    skipTransforms: true\n  });\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code highlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\n\n/**\n * Returns a boolean.\n * Check that the selection span is within a single CodeNode.\n * This is used to guard against executing handlers that can only be\n * applied in a single CodeNode context\n */\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();\n  const focusNode = selection.focus.getNode();\n  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();\n  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);\n}\n\n/**\n * Returns an Array of code lines\n * Take the sequence of LineBreakNode | TabNode | CodeHighlightNode forming\n * the selection and split it by LineBreakNode.\n * If the selection ends at the start of the last line, it is considered empty.\n * Empty lines are discarded.\n */\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      formatDevErrorMessage(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (lastLine.length > 0) {\n        lines.push(lastLine);\n        lastLine = [];\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  if (lastLine.length > 0) {\n    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;\n\n    // Discard the last line if the selection ends exactly at the\n    // start of the line (no real selection)\n    const lastPoint = $createPoint(lastLine[0].getKey(), 0, 'text');\n    if (!selectionEnd.is(lastPoint)) {\n      lines.push(lastLine);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  // 1. early decision when there is no real selection\n  if (anchor.is(focus)) {\n    return tabOrOutdent;\n  }\n\n  // 2. If only empty lines or multiple non-empty lines are selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length !== 1) {\n    return indentOrOutdent;\n  }\n  const codeLine = codeLines[0];\n  const codeLineLength = codeLine.length;\n  if (!(codeLineLength !== 0)) {\n    formatDevErrorMessage(`$getCodeLines only extracts non-empty lines`);\n  } // Take into account the direction of the selection\n  let selectionFirst;\n  let selectionLast;\n  if (selection.isBackward()) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  // find boundary elements of the line\n  // since codeLine only contains TabNode | CodeHighlightNode\n  // the result of these functions should is of Type TabNode | CodeHighlightNode\n  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);\n  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);\n  const anchorOfLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n  const focusOfLine = $createPoint(lastOfLine.getKey(), lastOfLine.getTextContentSize(), 'text');\n\n  // 3. multiline because selection started strictly before the line\n  if (selectionFirst.isBefore(anchorOfLine)) {\n    return indentOrOutdent;\n  }\n\n  // 4. multiline because the selection stops strictly after the line\n  if (focusOfLine.isBefore(selectionLast)) {\n    return indentOrOutdent;\n  }\n\n  // The selection if within the line.\n  // 4. If it does not touch both borders, it needs a tab\n  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {\n    return tabOrOutdent;\n  }\n\n  // 5. Selection is matching a full line on non-empty code\n  return indentOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n\n  // Special Indent case\n  // Selection is collapsed at the beginning of a line\n  if (codeLinesLength === 0 && selection.isCollapsed()) {\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n\n  // Special Indent case\n  // Selection is matching only one LineBreak\n  if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND && selection.getTextContent() === '\\n') {\n    const tabNode = $createTabNode();\n    const lineBreakNode = $createLineBreakNode();\n    const direction = selection.isBackward() ? 'previous' : 'next';\n    selection.insertNodes([tabNode, lineBreakNode]);\n    $setSelectionFromCaretRange($getCaretRangeInDirection($getCaretRange($getTextPointCaret(tabNode, 'next', 0), $normalizeCaret($getSiblingCaret(lineBreakNode, 'next'))), direction));\n    return true;\n  }\n\n  // Indent Non Empty Lines\n  for (let i = 0; i < codeLinesLength; i++) {\n    const line = codeLines[i];\n    // a line here is never empty\n    if (line.length > 0) {\n      let firstOfLine = line[0];\n\n      // make sure to consider the first node on the first line\n      // because the line might not be fully selected\n      if (i === 0) {\n        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);\n      }\n      if (type === INDENT_CONTENT_COMMAND) {\n        const tabNode = $createTabNode();\n        firstOfLine.insertBefore(tabNode);\n        // First real code line may need selection adjustment\n        // when firstOfLine is at the selection boundary\n        if (i === 0) {\n          const anchorKey = selection.isBackward() ? 'focus' : 'anchor';\n          const anchorLine = $createPoint(firstOfLine.getKey(), 0, 'text');\n          if (selection[anchorKey].is(anchorLine)) {\n            selection[anchorKey].set(tabNode.getKey(), 0, 'text');\n          }\n        }\n      } else if ($isTabNode(firstOfLine)) {\n        firstOfLine.remove();\n      }\n    }\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // siblings that can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = $getFirstCodeNodeOfLine(anchorNode);\n    end = $getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = $getFirstCodeNodeOfLine(focusNode);\n    end = $getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  const focusLineNode = focusNode;\n  const direction = $getCodeLineDirection(focusLineNode);\n  const moveToStart = direction === 'rtl' ? !isMoveToStart : isMoveToStart;\n  if (moveToStart) {\n    const start = $getStartOfCodeInLine(focusLineNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusLineNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = $getEndOfCodeInLine(focusLineNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  const registrations = [];\n\n  // Only register the mutation listener if not in headless mode\n  if (editor._headless !== true) {\n    registrations.push(editor.registerMutationListener(CodeNode, mutations => {\n      editor.getEditorState().read(() => {\n        for (const [key, type] of mutations) {\n          if (type !== 'destroyed') {\n            const node = $getNodeByKey(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }, {\n      skipInitialization: false\n    }));\n  }\n\n  // Add the rest of the registrations\n  registrations.push(editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the start of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_UP_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the end of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(KEY_ARROW_DOWN_COMMAND, event);\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, event => $handleMoveTo(MOVE_TO_START, event), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, event => $handleMoveTo(MOVE_TO_END, event), COMMAND_PRIORITY_LOW));\n  return mergeRegister(...registrations);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $getFirstCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;\n/** @deprecated renamed to {@link $getLastCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getLastCodeNodeOfLine = $getLastCodeNodeOfLine;\n/** @deprecated renamed to {@link $getEndOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getEndOfCodeInLine = $getEndOfCodeInLine;\n/** @deprecated renamed to {@link $getStartOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getStartOfCodeInLine = $getStartOfCodeInLine;\n\nexport { $createCodeHighlightNode, $createCodeNode, $getCodeLineDirection, $getEndOfCodeInLine, $getFirstCodeNodeOfLine, $getLastCodeNodeOfLine, $getStartOfCodeInLine, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeExtension, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguageOptions, getCodeLanguages, getCodeThemeOptions, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, normalizeCodeLang as normalizeCodeLanguage, registerCodeHighlighting };\n"],"mappings":"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","names":["Prism"]}