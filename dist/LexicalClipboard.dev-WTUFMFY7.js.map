{"version":3,"sources":["../node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $caretFromPoint, $isTextPointCaret, $getCaretRange, $getChildCaret, $getRoot, $isTextNode, $isElementNode, $parseSerializedNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = $caretFromPoint(anchor, 'previous');\n    if (anchorCaret) {\n      if ($isTextPointCaret(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = $getCaretRange(anchorCaret, $getChildCaret($getRoot(), 'next').getFlipped());\n        for (const caret of range) {\n          if ($isTextNode(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ($isElementNode(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && $isTextNode(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null && $isTextNode(target)) {\n    target = $sliceSelectedTextNodeContent(selection, target, 'clone');\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n  if ($isTextNode(target) && target.getTextContentSize() === 0) {\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    shouldInclude = false;\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = editorWindow.document;\n  const domSelection = getDOMSelection(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          editorWindow.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = editorWindow.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    const selection = $getSelection();\n    if (!selection || selection.isCollapsed()) {\n      return false;\n    }\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const [k] of clipboardDataFunctions) {\n    if (data[k] === undefined) {\n      clipboardData.setData(k, '');\n    }\n  }\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"mappings":"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","names":[]}